\documentclass[a4paper,12pt,fleqn]{scrartcl}
\usepackage[l2tabu,orthodox]{nag}% Old habits die hard. All the same, there are commands, classes and packages which are outdated and superseded. nag provides routines to warn the user about the use of those.

\usepackage[all,error]{onlyamsmath}% Error on deprecated math commands like $$ $$.
\usepackage[strict=true]{csquotes}

%\usepackage{color}

\usepackage{listings}
\lstset{frame=single,framerule=0pt,language={C},showstringspaces=false,numbers=left,columns=fullflexible}

 
% COMP2111-specific macros. See
% http://www.cse.unsw.edu.au/~cs2111/18s1/LaTeX/primer.html
\usepackage{2111defs2}
\usepackage[colorlinks=true]{hyperref}

\newcommand{\assn}[1]{{\color{red}\left\{#1\right\}}}
\newcommand{\remark}[1]{{\sffamily\color{blue}{#1}}}

%title variable
\title{Assignment 3}
\author{Ruofei HUANG(z5141448)\and
Anqi ZHU(z5141541)
}
 
% custom command for ass3
\newcommand{\domt}{\textbf{dom}(t)}
\newcommand{\WORD}{\textbf{word }}

% some old custom command
\newcommand{\variant}[3]{(#1:#2\mapsto #3)}
\newcommand{\ah}{\mathsf{a}}
\newcommand{\be}{\mathsf{b}}
\newcommand{\length}[1]{\left|#1\right|}
\newcommand{\noof}[2]{\left\|#1\right\|_{#2}}

\newcommand{\pre}{\mathit{pre}}
\newcommand{\post}{\mathit{post}}
\def\L{\mathcal{L}}
\begin{document}
\maketitle
\section{Task 1}
\subsection{Some useful symbol definitions about manipulating $\textbf{word}$s }
A $\textbf{word}$, as mentioned in the assignment specification, is defined as a 
finite sequence of letters over $L = \{'a', .., 'z'\}$. The specification 
already defines the relationship of '$\leq$' between a $\textbf{word}\ v$ and a 
$\textbf{word}\ w$ (this means $v$ is a prefix of $w$ or $w$ itself if 
$v\leq w$). 
\\\\
So we would like to further this definition and define a relationship of '$<$' 
when $v$ is a proper prefix of $w$ which cannot be $w$ itself if $v < w$. That 
means:
\begin{align*}
    v < w \Equiv v\leq w \And v\neq w
\end{align*}
We also would like to define a symbol $|w|$ that represents the length of a 
$word\ w$.We formally define this by:
\begin{align*}
    |w| = 
    \begin{cases}
        0 & \text{if } w = \epsilon\\
        1 + |w'| & \text{else }
    \end{cases}\\\\
    where\ \exists l\in L\ \{w = w'\ l\}
\end{align*} 
\subsection{Syntactic(Abstract) Data Type $Dict$ }
Inspired by the program sketch and the assignment statement, we could describe 
the syntactic data type $Dict$ as below (the encapsulated state would be a 
dictionary word set $W$).
\begin{align*}
    &Dict = 
    (
        W = \phi,  \\
        &\left( 
            \begin{array}{l}
                \PROC\ addword^{Dict}(\WORD w)\cdot 
                b, W:[\True, b = b_0\And W = W_0\cup \{w\}]\\
                \FUNC\ checkword^{Dict}(\WORD w):\mathbb{B}\cdot\\
                    \qquad 
                    \VAR\ b\cdot\ b, W:[\True, b = (w\in W)\And W = W_0];\ 
                    \RETURN\ b\\
                \PROC\ delword^{Dict}(\WORD w)\cdot
                b, W:[ w\in W, b = b_0\And W = W_0 \backslash \{w\}]
            \end{array}
        \right)
    )
\end{align*}
\section{Task 2}
\subsection{Data Type Refinement}
Now we would like to refine $Dict$ to a second data type $DictA$ where we 
replace $W$ with a trie $t$. We would also like to define the domain of a $t$ as
$\domt$. We shall use this definition later in our refinement.
\subsubsection{Inductive Relation Predicate}
The correspondence between the two state space $W$ and $t$ is captured by the 
inductively defined predicate as follows:
\begin{gather*}
    r = (W = 
    \{ 
        w \in \domt| t(w)=1
    \})
\end{gather*}
We can translate this into a relation function that transfers a concrete 
state space $t$ to an abstract state space $W$. The function is as follows:
\begin{gather*}
    f(t) = 
    \left\{
        w \in  \domt | t(w) = 1
    \right\}
\end{gather*}
With that in mind, we can propose the initialisation predicate and corresponding
operations of $DictA$.
\subsubsection{Initialisation Predicate}
We would like to define the initialisation predicate of DictA as follows:
\begin{gather*}
    init^{DictA} = (t\Ass\{\epsilon\mapsto 0\}) 
\end{gather*}
\subsubsection{Operations}
We would like to define the operations of DictA as follows:
\begin{gather*}
    \PROC\ addword^{DictA}(\WORD w)\cdot b, t:\\
        \qquad [\True, b = b_0\And t = {t_0\backslash\{w\mapsto 0 \} \cup\{w\mapsto 1\}\cup\{w' < w\And 
                    w'\notin \domt | w'\mapsto 0\}}]\\ 
    \FUNC\ checkword^{DictA}(\WORD w):\mathbb{B}\cdot
        \VAR\ b\cdot b, t:\\
        \qquad[\True, t = t_0\And b = (\All{w' \leq w}{w'\in \domt} \And t(w)=1)];\ \RETURN\ b\\
    \PROC\ delword^{DictA}(\WORD w)\cdot b, t:\\
        \qquad[\True , b = b_0\And
        (w \notin \domt \OR t = (t: w \mapsto 0))]\\ 
\end{gather*} 
\subsection{Proof of Refinement}
Now we would like to start proving the refinements of the initialization and 
each operation from $t$ to $W$. So that we can prove $DictA$ is a data 
refinement of $Dict$.
\subsubsection{Refinement proof for $init$}
We start from proving the refinement between $init^{DictA}$ and $init^{Dict}$.
\begin{align*}
    &init^{DictA} \Implies init^{Dict}\subst{f(t)}{W}\\
    \justification{Definition of $init^{DictA}$ and $init^{Dict}$}
    & \All {w \in \domt }{t(w)= 0} \Implies W = \phi
\end{align*}
Then we move on to prove the refinement of defined operations of $Dict$ and 
$DictA$. We don't need to prove the validity of the condition ($3_f$) for any 
operations since their preconditions are always \True. We only need to check the 
validity of the condition ($4_f$) in all three operations.
\subsubsection{Refinement proof for $addword$}
\begin{align*}
    &pre_{addword^{Dict}}\subst{f(t_0)}{W}\And post_{addword^{DictA}}\\
    \justification{Definition of $addword^{Dict}$ and $addword^{DictA}$ }
    % 
    & \True\subst{f(t_0)}{W} \And 
        b = b_0\And t = t_0\backslash\{w\mapsto 0 \}\cup \{w\mapsto 1\}\cup 
        \{
            w' < w \And w' \notin\domt | w' \mapsto 0
        \}\\
    %
    \justification[\Implies]{Definition of $f$ }
    &f(t)= f( t_0\backslash\{w\mapsto 0 \}\cup \{w\mapsto 1\}\cup 
    \{
        w' < w \And w' \notin\domt | w'\mapsto 0
    \})\\
    \justification{Logic, only $w$ maps to 1 in $t$(only $w$ is newly added into $W$)} 
    &f(t)= f(t_0)\cup \{w\}\\ 
    \justification{Definition of $addword^{Dict}$ and $addword^{DictA}$ }
    &post_{addword^{Dict}}\subst{f(t_0),f(t)}{W_0, W}
\end{align*}
\subsubsection{Refinement proof for $checkword$}
\begin{align*}
    &pre_{checkword^{Dict}}\subst{f(t_0)}{W}\And post_{checkword^{DictA}}\\
    \justification{Definition of $checkword^{DictA}$ and $checkword^{Dict}$}
    &\True\subst{f(t_0)}{W} \And t = t_0\And 
    b = (\All{w' \leq w}{w'\in \domt} \And t(w)=1)\\
    %
    \justification[\Implies]{Definition of $f$}
    &b = (w \in f(t)\And t(w)= 1)\And t = t_0\\
    \justification{Definition of $checkword^{DictA}$ and $checkword^{Dict}$}
    & post_{checkword^{Dict}}\subst{f(t_0),f(t)}{W_0,W}
\end{align*}
\subsubsection{Refinement proof for $delword$}
\begin{align*}
    &pre_{delword^{Dict}}\subst{f(t_0)}{W}\And post_{delword^{DictA}}\\
    \justification{Definition of $delword^{DictA}$ and $delword^{Dict}$}
    &w\in f(t_0) \And b = b_0\And
        (w \notin \domt \OR t =(t: w \mapsto 0))\\
    \justification[\Implies]{Definition of $f$}
    &f(t) = f(t_0)\backslash\{w\}\\
    \justification{Definition of $delword^{DictA}$ and $delword^{Dict}$}
    &post_{delword^{Dict}}\subst{f(t_0),f(t)}{W_0,W}
\end{align*}

\section{Task 3}
\subsection{Pre-defined function calls}
Before refining the operations in $DictA$ into toy language, we would like to 
first define some useful function calls that helps building our later refinement 
more close to the real c program constructions.
\subsubsection{$POPWORD$}
The semantic function $POPWORD$ returns a substring $w'$ of the word $w$ 
starting from the first letter to the $index$'th letter of $w$. The definition 
of the function and corresponding function call is as below:\\\\
\textbf{Definition of $POPWORD$}
\begin{gather*}
    POPWORD(w,i) = w'\ \ \ \ \ \ where\ w' \leq w \And |w'| = i
\end{gather*}
\textbf{Definition of the function call $popWord$}
\begin{gather*}
    \FUNC\ popWord(\VALUE\ w, \VALUE\ i ): \WORD\cdot\\
    \qquad \VAR\ w' \cdot 
    \nt{
        w':[
            i \leq |w|,
            w'\leq w \And |w'| = i
        ];  
    }{(P1)}
    \RETURN\ w' 
\end{gather*}
\textbf{Specification of the procedure in $popWord$}
\begin{align*}
    \lrefstep{(P1)}{$|w[0..i-1]| = i \And w[0..i-1] \leq w$}{
        w'\Ass w[0..i-1]
    }
\end{align*}
This function helps us to build our refinement as close to the trie construction 
in c programs as possible. (In c programs, words are splitted into prefixes in 
increasing length and checked in the trie recursively.)
\subsubsection{$doAddword$}
Using the previous definition of $POPWORD$, we would like to develop a 
corresponding function call named 
$doAddword(\textbf{var}\ w, \textbf{var}\ index)$
that allows using a variable $i$ to locate which prefix of $w$(or say which 
sub-trie of $t$) the procedure currently is checking at during the entire 
word-adding operation. This function will be called by the function $addword$ of
$DictA$ to do most of the adding-word job.\\\\
All the prefixes of $w$ should exist in $t$ eventually, 
so if the current prefix $POPWORD(w, i)$ does not exist, $doAddword$ will add 
the new prefix into $t$ and continue searching for the next prefix 
$POPWORD(w, i+1)$. Considering this and the fact that $t$ always initializes 
with $\epsilon$ included, it is guaranteed that every $doAddword$ operation at 
$i$ level will already have all prefixes of $w$ with length no longer than $i$ 
exist in $t$, which satisfies the precondition of the $doAddword$ function 
itself. The definition of the function and the refinement of its linking 
procedure is as follows.\\\\
\textbf{Definition of $doAddword$}
\begin{gather*}
    \PROC\ doAddword^{DictA}(\VALUE\ w,\VALUE\ index)\\
        \qquad
        \nt{
            t:\left[\begin{array}{l}
                0\leq index \leq |w|\And
                \All{w'\leq w \And |w'|\leq index}{w'\in \domt},\\
                t = {t_0\backslash\{w\mapsto 0 \} \cup\{w\mapsto 1\}
                \cup\{w' < w\And w'\notin \domt | w'\mapsto 0\}}]
            \end{array}
            \right]
        }{(A2)}
\end{gather*}
\textbf{Specification of the procedure in $doAddword$}
\begin{align*}
    \lrefstep{(A2)}{if}{
        \IF ~ index < |w| ~ \\ 
        &\THEN 
        \nt{
            t:[ index < |w|\And \pre{(A2)}, \post{(A2)}]
        }{(A3-1)} \\
        &\ELSE 
        \nt{
            t:[ index \geq |w| \And \pre{(A2)}, \post{(A2)}]
        }{(A3-2)}\\
        &\FI\\
    }
    \lrefstep{(A3-1)}{seq}{
        \nt{
            t:\left[\begin{array}{l}
                index < |w| \And \pre{(A2)}, \\
                index \geq |w| \And \pre{(A2)}
                \And POPWORD(w, index+1)\in\domt
            \end{array}\right]
        }{(A3-3)}
        \\
        &
        \nt{
            t:\left[\begin{array}{l}
                index \geq |w| \And \pre{(A2)}
                \And POPWORD(w, index+1)\in\domt,\\
                \post{(A2)}
            \end{array}\right]
        }{(A3-4)}
    }\\
    \lrefstep{(A3-3)}{if}{
        \IF ~(POPWORD(w,index+1)\in \domt)~\\
        &\THEN\ \nt{
            t:\left[\begin{array}{l}
                \pre{(A3-3)}\And POPWORD(w,index+1)\in\domt,\\
                \post{(A3-3)}
            \end{array}\right]
        }{(A3-3-1)} \\ 
        &\ELSE\ \nt{
            t:\left[\begin{array}{l}
                \pre{(A3-3)}\And POPWORD(w,index+1)\notin\domt,\\
                \post{(A3-3)}
            \end{array}\right]
        }{(A3-3-2)}\\
        &\FI \\
    }
    \lrefstep{(A3-3-1)}{$POPWORD(w,index+1)\in\domt 
        \Implies \post{(A3-3)}=\True$}{
        skip;
    }\\
    \lrefstep{(A3-3-2)}{Ass}{
        t \Ass t\cup \{ popWord(w,index) \mapsto 0\};
    }\\
    \lrefstep{(A3-4)}{proc}{
        doAddword(w, index +1)
    }\\
    \lrefstep{(A3-2)}{$index \geq |w| \And index \leq |w| \Implies 
        index = |w|$ and definition of $\post{(A2)}$}{
        t \Ass t_0 \backslash \{ w\mapsto 0 \} \cup \{ w \mapsto 1\}
    }
\end{align*}
We gather the code for the body of $doAddword$
\begin{gather*}
    \IF\ ~index<|w|~\\
    \THEN\ \\
    \qquad \IF\ ~POPWORD(w,index+1)\in\domt~\\
    \qquad \THEN\ skip;\\
    \qquad \ELSE\\
    \qquad\qquad t\Ass t \cup \{popWord(w,index)\mapsto 0 \};\\
    \qquad \FI\ \\
    \qquad doAddword(w, index +1)\\
    \ELSE \\
    \qquad t \Ass t_0 \backslash \{ w\mapsto 0 \} \cup \{ w \mapsto 1\}\\
    \FI
\end{gather*}

\subsubsection{$doCheckword$}
Similarly to $doAddword$, we would also develop a corresponding function call 
named $doCheckword(\textbf{var}\ w, \textbf{var}\ index)$ which will search the
complete word $w$ in $t$ based on the precondition that all prefixes of $w$ with
length no longer than $index$ are guaranteed to exist in $t$. This function 
would be called by $checkword$ of $DictA$ to do most of the checking-word job.
The definition of the function and the refinement of its linking procedure is as
follows.\\\\
\textbf{Definition of doCheckword}
\begin{gather*}
    \FUNC\ doCheckword(\VALUE\ w, \VALUE\ index:\nat ):\mathbb{B}\cdot \\
        \qquad\VAR\ b\cdot 
        \nt{
            b: 
            \left[\begin{array}{l}
                0\leq index \leq |w|\And\\
                \All{w'\leq w\And |w'|\leq index}{w'\in\domt},\\
                b = (\All{w' \leq w}{w'\in \domt} \And t(w)=1)
            \end{array}
            \right]
        }{(C2)} 
        ;\RETURN\ b
\end{gather*}
\textbf{Specification of the procedure in doCheckword}
\begin{align*}
    \lrefstep{(C2)}{if}{
        \IF ~ index < |w| ~ \\ 
        &\THEN 
        \nt{
            b:[ index < |w|\And \pre{(C2)}, \post{(C2)}]
        }{(C3-1)} \\
        &\ELSE 
        \nt{
            b:[ index \geq |w| \And \pre{(C2)}, \post{(C2)}]
        }{(C3-2)}\\
        &\FI\\
    }
    % TODO: try to use an early return, but there is not in Toy languague
    %       How to check whether the prefix is in the dom(t) 
    \lrefstep{(C3-1)}{if}{
        \IF ~(POPWORD(w,index+1)\in \domt)~\\
        &\THEN\ \nt{
            b:\left[\begin{array}{l}
                \pre{(C3-1)}\And POPWORD(w,index+1)\in\domt,\\
                \post{(C2)}
            \end{array}\right]
        }{(C3-1-1)} \\ 
        &\ELSE\ \nt{
            b:\left[\begin{array}{l}
                \pre{(C3-1)}\And POPWORD(w,index+1)\notin\domt,\\
                \post{(C2)}
            \end{array}\right]
        }{(C3-1-2)}\\
        &\FI \\
    }
    \lrefstep{(C3-1-1)}{ass, func}{
        b\Ass doCheckword(w, index +1)
    }\\
    \lrefstep{(C3-1-2)}{Ass and $popWord(w,index+1)\notin\domt 
                \Implies b = \False$ }{
        b\Ass \False
    }\\
    \lrefstep{(C3-2)}{$index \geq |w| \And index \leq |w| \Implies 
    index = |w|$ and definition of $\post{(C2)}$}{
        b\Ass (t(w) = 1) 
    }
\end{align*}
We gather the code of $doCheckword$ below:
\begin{gather*}
    \IF\ ~index < |w|~ \\
    \THEN \\
    \qquad \IF\ ~POPWORD(w,index+1) \in \domt~ \\
    \qquad \THEN\ skip\\
    \qquad \ELSE\ \RETURN\ doCheckword(w,index+1) \\
    \qquad \FI \\
    \ELSE\ b\Ass (t(w) = 1)\\
    \FI 
\end{gather*}
\subsubsection{$doDelword$}
Similarly to $doCheckword$, we would also develop a corresponding function call 
named $doDelword(\textbf{var}\ w, \textbf{var}\ index)$ which will set the 
result of $t(w)$ as 0. This function would be called by $delword$ of $DictA$ to
do most of the deleting-word job. The definition of the function and the 
refinement of its linking procedure is as follows.\\\\
\textbf{Definition of doDelword}
\begin{gather*}
    \PROC\ doDelword^{DictA}(\VALUE\ w,\VALUE\ index)\\
        \qquad
        \nt{t:\left[\begin{array}{l}
            0\leq index \leq |w|\And 
            \All{w'\leq w \And |w'|\leq index}{w'\in \domt},\\
            (w \notin \domt \OR t= t_0: w \mapsto 0)
        \end{array}\right]}{(D2)}
\end{gather*}
\textbf{Specification of the procedure in doDelword}
\begin{align*}
    \lrefstep{(D2)}{if}{
        \IF ~ index < |w| ~ \\ 
        &\THEN 
        \nt{
            t:[ index < |w|\And \pre{(D2)}, \post{(D2)}]
        }{(D3-1)} \\
        &\ELSE 
        \nt{
            t:[ index \geq |w| \And \pre{(D2)}, \post{(D2)}]
        }{(C3-2)}\\
        &\FI\\
    }
    \lrefstep{(D3-1)}{if}{
        \IF ~(POPWORD(w,index+1)\in \domt)~\\
        &\THEN\ \nt{
            t:\left[\begin{array}{l}
                \pre{(D3-1)}\And POPWORD(w,index+1)\in\domt,\\
                \post{(D2)}
            \end{array}\right]
        }{(D3-1-1)} \\ 
        &\ELSE\ \nt{
            t:\left[\begin{array}{l}
                \pre{(D3-1)}\And POPWORD(w,index+1)\notin\domt,\\
                \post{(D2)}
            \end{array}\right]
        }{(D3-1-2)}\\
        &\FI \\
    }
    \lrefstep{(D3-1-1)}{ass, func}{
        doDelword(w, index +1)
    }\\
    \lrefstep{(D3-1-2)}{Ass and $POPWORD(w,index+1)\notin\domt 
                \Implies \post(D2) =\True$ }{
        skip
    }\\
    \lrefstep{(D3-2)}{$index \geq |w| \And index \leq |w| \Implies 
    index = |w|$ and definition of $\post{(D2)}$}{
        t\Ass (t: w\mapsto 0)
    }
\end{align*}
We gather the code of $doDelword$ below:
\begin{gather*}
    \IF\ ~index < |w|~ \\
    \THEN\ \\
    \qquad \IF\ ~POPWORD(w, index +1)\in\domt ~ \\
    \qquad \THEN\ doDelword(w, index+1)\\
    \qquad \ELSE\ skip\\
    \qquad \FI \\
    \ELSE\ t\Ass (t: w \mapsto 0)\\
    \FI
\end{gather*}
Now we could specify the initialisation and all operations of $DictA$ into toy 
language, in which above functions will be called to do the corresponding jobs. 
\subsection{Specification of $init$}
From the spec we have:
\begin{align*}
    &\domt =\{\epsilon\} \And f(t)= \phi\\
    \refstep{ass}{t \Ass \{\epsilon \mapsto 0\}}
\end{align*}
\subsection{Specification of $addword$}
From the spec\footnote{Definition of this is in the Assignment 3 requirements of
cs2111.} we have:
\begin{gather*}
    \PROC\ addword^{DictA}(\VALUE\ w)\cdot \\
        \qquad
        \nt{
            b, t:[\True, b = b_0\And t = {t_0\backslash\{w\mapsto 0 \} \cup\{w\mapsto 1\}\cup\{w' < w\And 
            w'\notin \domt | w'\mapsto 0\}}]
        }{(A1)}
\end{gather*}
\begin{align*}
    \lrefstep{(A1)}{c-frame}{
        t:[\True,t = {t_0\backslash\{w\mapsto 0 \} \cup\{w\mapsto 1\}\cup\{w' < w\And 
        w'\notin \domt | w'\mapsto 0\}}]
    }\\
    \refstep{if}{
        \IF ~w=\epsilon~\\
        &\THEN\ \nt{
            b:\left[\begin{array}{l}
                \pre{(A1)}\And w=\epsilon,\\
                \post{(A1)}
            \end{array}\right]
        }{(A1-s)} \\ 
        &\ELSE\ \nt{
            b:\left[\begin{array}{l}
                \pre{(A1)}\And w\neq\epsilon,\\
                \post{(A1)}
            \end{array}\right]
        }{(A1-c)}\\
        &\FI \\
    }
    \lrefstep{(A1-s)}{$\epsilon$ already exists in $\domt$}{
        t\Ass (t:w\mapsto 1)
    }\\
    \lrefstep{(A1-c)}{proc, $ 0 \leq |w|$ and $\epsilon\in\domt$ since 
    $init^{DictA}$}{
        doAddword(w, 0)
    }
\end{align*}
We gather the code for the body of $addword$
\begin{gather*}
    \IF\ ~w=\epsilon~\\
    \THEN\ t\Ass (t:w\mapsto 1)\\
    \ELSE \\
    \qquad doAddword(w, 0)\\
    \FI
\end{gather*}
\subsection{Specification of $checkword$}
From the spec we have:
\begin{gather*}
    \FUNC\ checkword^{DictA}(\VALUE\ w):\mathbb{B}\cdot \\
        \qquad
        \VAR\ b\cdot\nt{
            b, t:
            [\True, b = (\All{w' \leq w}{w'\in \domt} \And t(w)=1)];}{(C1)}
        \ \RETURN\ b
\end{gather*}
\begin{align*}
    \lrefstep{(C1)}{c-frame}{
        b:[\True, b = (\All{w' \leq w}{w'\in \domt} \And t(w)=1)];
    }\\
    \refstep{if}{
        \IF ~w=\epsilon~\\
        &\THEN\ \nt{
            b:\left[\begin{array}{l}
                \pre{(C1)}\And w=\epsilon,\\
                \post{(C1)}
            \end{array}\right]
        }{(C1-s)} \\ 
        &\ELSE\ \nt{
            b:\left[\begin{array}{l}
                \pre{(C1)}\And w\neq\epsilon,\\
                \post{(C1)}
            \end{array}\right]
        }{(C1-c)}\\
        &\FI \\
    }
    \lrefstep{(C1-s)}{$\epsilon$ already exists in $\domt$}{
        b\Ass (t(w)=1) 
    }\\
    \lrefstep{(C1-c)}{proc, $ 0 \leq |w|$ and $\epsilon\in\domt$ since 
            $init^{DictA}$}
    {
        b\Ass doCheckword(w, 0);
    }
\end{align*}
We gather the code for the body of $checkword$
\begin{gather*}
    \IF\ ~w=\epsilon~\\
    \THEN\ \\
    \qquad b\Ass (t(w)=1);\\
    \ELSE \\
    \qquad b\Ass doCheckword(w, 0);\\
    \FI\\
    \textbf{return}\ b    
\end{gather*}
\subsection{Specification of $delword$}
From the spec we have:
\begin{gather*}
    \PROC\ delword^{DictA}(\VALUE\ w)\\
        \qquad 
        \nt{
            \cdot b, t:
            [\True , b = b_0\And
            (w \notin \domt \OR t\Ass t: w \mapsto 0)]
        }{(D1)}    
\end{gather*}
\begin{align*}
    \lrefstep{(D1)}{c-frame}{
        t:[\True ,(w \notin \domt \OR t= t_0: w \mapsto 0)]
    }\\
    \refstep{if}{
        \IF ~w=\epsilon~\\
        &\THEN\ \nt{
            b:\left[\begin{array}{l}
                \pre{(D1)}\And w=\epsilon,\\
                \post{(D1)}
            \end{array}\right]
        }{(D1-s)} \\ 
        &\ELSE\ \nt{
            b:\left[\begin{array}{l}
                \pre{(D1)}\And w\neq\epsilon,\\
                \post{(D1)}
            \end{array}\right]
        }{(D1-c)}\\
        &\FI \\
    }
    \lrefstep{(D1-s)}{$\epsilon$ already exists in $\domt$}{
        t\Ass (t: w\mapsto 0) 
    }\\
    \lrefstep{(D1-c)}{proc, $ 0 \leq |w|$ and $\epsilon\in\domt$ since 
        $init^{DictA}$}{
        doDelword(w, 0)
    } 
\end{align*}
We gather the code for the body of $delword$
\begin{gather*}
    \IF\ ~w=\epsilon~\\
    \THEN\ \\
    \qquad t\Ass (t: w\mapsto 0)\\
    \ELSE \\
    \qquad doDelword(w, 0)\\
    \FI
\end{gather*}
\subsection{Task 4}
Now we would translate our data refinement to C functions to match the
prototypes given in dict.h. \\\\
There are some significant differences between the structure of a trie used in c 
functions and in our data refinement (because the tries in c functions can be 
operated as nodes but they are operated as sets in our data refinement). The 
created new word/prefix attaches to the current trie by being linked to a pointer 
in its sub-trie, while in our data refinement, $t$ absorbs the new word/prefix 
$w$ by combining a new function subset containing $w$ in its domain. Also, the 
trie in c functions uses sub-tries to recursively find the next extend prefix/word,
while in our data refinement, we uses the extension of a substring of $w$ ($POPWORD$)
to represent the next level of sub-trie.\\\\
However, it should be noted that the logic used on both sides is the same (they 
both use recursive call to derive the final result). So we can say that our data 
refinement is a well representation of our c functions.
\lstinputlisting{dict.c}
\end{document}