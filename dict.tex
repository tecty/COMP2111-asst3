\documentclass[a4paper,12pt,fleqn]{scrartcl}
\usepackage[l2tabu,orthodox]{nag}% Old habits die hard. All the same, there are commands, classes and packages which are outdated and superseded. nag provides routines to warn the user about the use of those.

\usepackage[all,error]{onlyamsmath}% Error on deprecated math commands like $$ $$.
\usepackage[strict=true]{csquotes}

%\usepackage{color}

\usepackage{listings}
\lstset{frame=single,framerule=0pt,language={C},showstringspaces=false,numbers=left,columns=fullflexible}


% COMP2111-specific macros. See
% http://www.cse.unsw.edu.au/~cs2111/18s1/LaTeX/primer.html
\usepackage{2111defs2}
\usepackage[colorlinks=true]{hyperref}

\newcommand{\assn}[1]{{\color{red}\left\{#1\right\}}}
\newcommand{\remark}[1]{{\sffamily\color{blue}{#1}}}

% define some convenience macros specific to this task
\newcommand{\perm}{\mathsf{perm}}
%title variable
\title{Assignment 3}
\author{Ruofei HUANG(z5141448)\and
Anqi ZHU(z5141541)
}

% custom command for ass3
\newcommand{\domt}{\textbf{dom}(t)}
\newcommand{\WORD}{\textbf{word }}

% some old custom command
\newcommand{\variant}[3]{(#1:#2\mapsto #3)}
\newcommand{\oldwhatever}[4]{\variant{#1}{#2}{\variant{#1[#2]}{#3}{#4}}}
\newcommand{\whatever}[4]{\variant{#1}{#2\mapsto #3}{#4}}
\newcommand{\ah}{\mathsf{a}}
\newcommand{\be}{\mathsf{b}}
\newcommand{\length}[1]{\left|#1\right|}
\newcommand{\noof}[2]{\left\|#1\right\|_{#2}}

\newcommand{\pre}{\mathit{pre}}
\newcommand{\post}{\mathit{post}}
\def\L{\mathcal{L}}
\begin{document}
\maketitle
\section{Task 1}
\subsection{Some useful symbol definitions about manipulating $\textbf{word}$s }
A $\textbf{word}$, as mentioned in the assignment specification, is defined as a 
finite sequence of letters over $L = {'a', .., 'z'}$. The specification already 
defines the relationship of '$\leq$' between a $\textbf{word}\ v$ and a 
$\textbf{word}\ w$ (which means $v$ is a prefix of $w$ or $w$ itself if 
$v\leq w$). \\\\
% TODO: Add a more definition here. 
So we would like to further this definition and define a relationship of '$<$' 
when $v$ is a pure prefix of $w$ which cannot be $w$ itself if $v < w$. That 
means:
\begin{align*}
    v < w \Equiv v\leq w \And v\neq w
\end{align*}
% TODO: Add definition of |w|
We also would like to define a symbol $|w|$ that represents the length of a 
$word\ w$.We formally define this by:
\begin{align*}
    |w| = 
    \begin{cases}
        0 & \text{if } w = \epsilon\\
        1 + |w'| & \text{else }
    \end{cases}\\\\
    where\ \exists l\in L\ \{w = w'\ l\}
\end{align*} 
\subsection{Syntactic(Abstract) Data Type $Dict$ }
% TODO: init^{Dict} is missing?
Inspired by the program sketch and the assignment statement, we could describe 
the syntactic data type $Dict$ as below (the encapsulated state would be a 
dictionary word set $W$).
\begin{align*}
    &Dict = 
    (
        W = \phi,  \\
        &\left( 
            \begin{array}{l}
                \PROC\ addword^{Dict}(\WORD w)\cdot 
                b, W:[\True, b = b_0\And W = W_0\cup \{w\}]\\
                \FUNC\ checkword^{Dict}(\WORD w):\mathbb{B}\cdot
                    \VAR\ b\cdot\ b, W:[\True, b = (w\in W_0)];\ 
                    \RETURN\ b\\
                \PROC\ delword^{Dict}(\WORD w)\cdot
                b, W:[ w\in W, b = b_0\And W = W_0 \backslash \{w\}]
            \end{array}
        \right)
    )
\end{align*}
\section{Task 2}
% \subsection{Data Invariant} 
% \begin{gather*}
%     \All{w \in \domt,t(w)= 1, w' \leq w}{w' \in \domt}
% \end{gather*}
\subsection{Data Type Refinement}
Now we would like to refine $Dict$ to a second data type $DictA$ where we 
replace $W$ with a trie $t$. We would also like to define the domain of a $t$ as
$\domt$. We shall use this definition later in our refinement.
\subsubsection{Inductive Relation Predicate}
The correspondence between the two state space $W$ and $t$ is captured by the 
inductively defined predicate. 
\begin{gather*}
    r = (W = 
    \{ 
        w \in \domt| t(w)=1
    \})
\end{gather*}
which we can translate into a relation function that transfers a concrete 
state space $t$ to an abstract state space $W$:
\begin{gather*}
    f(t) = 
    \left\{
        w \in  \domt | t(w) = 1
    \right\}
\end{gather*}
With that in mind, we can propose the initialisation predicate and corresponding
operations of $DictA$.
\subsubsection{Initialisation Predicate}
We would like to define the initialisation predicate of DictA as follows:
\begin{gather*}
    init^{DictA} = (t\Ass\{\epsilon\mapsto 0\}) 
\end{gather*}
\subsubsection{Operations}
We would like to define the operations of DictA as follows:
\begin{gather*}
    \PROC\ addword^{DictA}(\WORD w)\cdot b, t:\\
        \qquad [ \ \True, b = b_0\And \\
        \qquad\qquad t = \left( 
                \begin{array}{l}
                    w\notin \domt\And t = {t_0\cup\{w\mapsto 1\}\cup\{w' < w\And 
                    w'\notin \domt | w'\mapsto 0\}}\\
                    w\in\domt\And t = (t_0:w\mapsto 1)\\
                \end{array}
            \right)]\\
    \FUNC\ checkword^{DictA}(\WORD w):\mathbb{B}\cdot
        \VAR\ b\cdot b, t:\\
        \qquad[\True, t = t_0\And b = (w\in \domt\And t(w)=1)];\ \RETURN\ b\\
    \PROC\ delword^{DictA}(\WORD w)\cdot b, t:\\
        \qquad[\True , b = b_0\And
        (w \notin \domt \OR t\Ass(t: w \mapsto 0))]\\ 
\end{gather*} 
\subsection{Proof of Refinement}
Now we would like to start proving the refinements of the initialization and 
each operation from $t$ to $W$. \\\\
We start from proving the refinement between $init^{DictA}$ and $init^{Dict}$.
\begin{align*}
    &init^{DictA} \Implies init^{Dict}\subst{f(t)}{W}\\
    \justification{Definition of $init^{DictA}$ and $init^{Dict}$}
    & \All {w \in \domt }{t(w)= 0} \Implies W = \phi
\end{align*}
Since all our precondition of concrete is trivial which all of them are \True, 
we don't need to proof the condition ($3_f$).But condition ($4_f$) must be 
checked for all three operations.\\
For the $addword$ we proof:
\begin{align*}
    &pre_{addword^{Dict}}\subst{f(t_0)}{W}\And post_{addword^{DictA}}\\
    \justification{Definition of $addword^{Dict}$ and $addword^{DictA}$ }
    % 
    & \True\subst{f(t_0)}{W} \And 
        b = b_0\And t = t_0\cup \{w\mapsto 1\}\cup 
        \{
            w' < w \And w' \notin\domt | w' \mapsto 0
        \}\\
    %
    \justification[\Implies]{Definition of $f$ }
    &f(t)= f( t_0\cup \{w\mapsto 1\}\cup 
    \{
        w' < w \And w' \notin\domt | w'\mapsto 0
    \})\\
    \justification{Logic} 
    &f(t)= f(t_0)\cup \{w\}\\ 
    \justification{Definition of $addword^{Dict}$ and $addword^{DictA}$ }
    &post_{addword^{Dict}}\subst{f(t_0),f(t)}{W_0, W}
\end{align*}
For the $checkword$ we proof:
\begin{align*}
    &pre_{checkword^{Dict}}\subst{f(t_0)}{W}\And post_{checkword^{DictA}}\\
    \justification{Definition of $checkword^{DictA}$ and $checkword^{Dict}$}
    &\True\subst{f(t_0)}{W} \And b = (w\in \domt\And t = t_0 )\\
    %
    \justification[\Implies]{Definition of $f$}
    &b = (w \in f(t))\And t = t_0\\
    \justification{Definition of $checkword^{DictA}$ and $checkword^{Dict}$}
    & post_{checkword^{Dict}}\subst{f(t_0),f(t)}{W_0,W}
\end{align*}
For the $delword$ we proof:
\begin{align*}
    &pre_{delword^{Dict}}\subst{f(t_0)}{W}\And post_{delword^{DictA}}\\
    \justification{Definition of $delword^{DictA}$ and $delword^{Dict}$}
    &w\in f(t_0) \And b = b_0\And
        (w \notin \domt \OR t\Ass t: w \mapsto 0)\\
    \justification[\Implies]{Definition of $f$}
    &f(t) = f(t_0)\backslash\{w\}\\
    \justification{Definition of $delword^{DictA}$ and $delword^{Dict}$}
    &post_{delword^{Dict}}\subst{f(t_0),f(t)}{W_0,W}
\end{align*}

\section{Task 3}
We derive our code in to fours part by $init$ and its operations. 
\subsection{init}
From the spec we have:
\begin{align*}
    &\domt =\{\epsilon\} \And f(t)= \phi\\
    \refstep{ass}{t \Ass \{\epsilon \mapsto 0\}}
\end{align*}

\subsection{addword}
From the spec we have:
\begin{gather*}
    \PROC\ addword^{DictA}(\WORD w)\cdot \\
        \qquad   
        \nt{
            b, t:[\True, b = b_0\And t = t_0\cup \{w\mapsto 1\}\cup 
            \{
                w' < w \And w' \notin \domt | w' \mapsto 0
            \}]
        }{(A1)}
\end{gather*}
\begin{align*}
    \lrefstep{(A1)}{c-frame}{
        t:[\True,t = t_0\cup \{w\mapsto 1\}\cup 
        \{
            w' < w \And w' \notin \domt | w' \mapsto 0
        \}]
    }
\end{align*}
\subsection{checkword}
From the spec we have:
\begin{gather*}
    \FUNC\ checkword^{DictA}(\WORD w)\\
        \qquad
        \nt{
            \mathbb{B}\cdot \VAR\ b\cdot b, t:
            [\True, b = (w\in \domt\And t = t_0)];\ \RETURN\ b
        }{(C1)}
\end{gather*}
\begin{align*}
    \lrefstep{(C1)}{c-frame}{
        \mathbb{B}\cdot \VAR\ b\cdot b:
        [\True, b = (w\in \domt)];\ \RETURN\ b
    }\\
    \refstep{proc, $ 0 \leq |w|$ }
    {
        \RETURN\ doCheckword(w, 0);
    }
\end{align*}
Where we define a recursive procedure call to do the dirty work also align the 
pre and post condition: 
\begin{gather*}
    \FUNC\ doCheckword(\WORD w, \VAR\ index:\nat )\\
        \qquad
        \nt{
            \mathbb{B}\cdot \VAR\ b\cdot b, \VAR\ index
            [prefix \leq w, b = (w\in \domt)];\ \RETURN\ b
        }{(C2)}
\end{gather*}
\begin{align*}
    \lrefstep{(C2)}{if}{
        \IF ~ index < |w| ~ \\ 
        &\THEN 
        \nt{
            b,indexp[ index < |w|\And \pre{(C2)}, \post{(C2)}]
        }{(C3-1)} \\
        &\ELSE 
        \nt{
            b,index[ index < |w| \And \pre{(C2)}, \post{(C2)}]
        }{(C3-2)}\\
        &\FI\\
    }
    \lrefstep{(C3-1)}{func}{
        \RETURN\ doCheckword(w, index +1);
    }
\end{align*}
\subsection{delword}
From the spec we have:
\begin{gather*}
    \PROC\ delword^{DictA}(\WORD w)\\
        \qquad
        \nt{
            \cdot b, t:
            [\True , b = b_0\And
            (w \notin \domt \OR t\Ass t: w \mapsto 0)]
        }{(D1)}    
\end{gather*}


\end{document}